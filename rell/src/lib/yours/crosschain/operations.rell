@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_overridable_auth_handler(
    scope = rell.meta(init_transfer).mount_name,
    flags = ["T"]
  );

/**
 * This operation initializes the transfer metadata for a token transfer.
 * It is executed on the source blockchain that you want to transfer the
 * token away from.
 *
 * It is an extension of the FT4 ICCF flow and the purpose is to
 * pass (the correct) metadata of tokens to the target chain.
 *
 * @param metadata The metadata to be initialized for the transfer. Expected to be in `gtv_pretty` format.
 */
operation init_transfer(
  recipient_id: byte_array,
  project: name,
  collection: name,
  token_id: integer,
  amount: integer,
  metadata: gtv
) {
  val account = ft4.auth.authenticate();

  val token = require(get_token(project, collection, token_id), "Token Not Found");
  val existing_metadata = get_metadata(token).to_gtv_pretty();
  require(existing_metadata == metadata, "Invalid Metadata");

  before_init_transfer(token, account);
  burn(token, balance_info(account, amount));
  after_init_transfer(token, account);
}

/**
 * This operation applies the transfer metadata to a token transfer.
 * It is executed against the target blockchain where you want the
 * token to be imported into.
 */
operation apply_transfer(
  init_transfer_tx: gtx_transaction,
  init_tx_op_index: integer
) {
  val (init_transfer_details, _) = _validate_apply_transfer(
    init_transfer_tx,
    init_tx_op_index
  );

  // Add transfer to applied transfers table so that it cannot be applied more than once
  create applied_transfers (
    init_tx_rid = init_transfer_details.tx_rid,
    init_op_index = init_tx_op_index,
    transaction = op_context.transaction,
    op_index = op_context.op_index
  );

  val transferred_metadata = token_metadata.from_gtv_pretty(init_transfer_details.args.metadata);
  var token = get_token(
    transferred_metadata.yours.project,
    transferred_metadata.yours.collection,
    init_transfer_details.args.token_id
  );

  if (token == null) {
    token = create_token_with_id(
      token_info(
        project = transferred_metadata.yours.project,
        collection = transferred_metadata.yours.collection,
        name = transferred_metadata.name,
        modules = transferred_metadata.yours.modules
      ),
      init_transfer_details.args.token_id
    );
  }

  _apply_transfer(
    init_transfer_details.sender_account_id,
    token,
    init_transfer_details.args.amount,
    transferred_metadata
  );
}

function _apply_transfer(account_id: byte_array, token, amount: integer, token_metadata) {
  mint(token, balance_info(ft4.accounts.account @ { account_id }, amount));
  _apply_common_metadata(token, token_metadata);

  val imported_attributes = imported_attributes @? { token };
  if (imported_attributes == null) {
    create imported_attributes ( token, token_metadata.attributes.to_gtv().to_json() );
  } else {
    imported_attributes.json = token_metadata.attributes.to_gtv().to_json();
  }

  val attributes = map<name, gtv>();
  for (attribute in token_metadata.attributes) {
    attributes.put(attribute.trait_type, attribute.value);
  }

  after_apply_transfer(token, set(token_metadata.yours.modules), attributes);
}

function _apply_common_metadata(token, metadata: token_metadata) {
  attach_image(token, metadata.image);
  attach_description(token, metadata.description);
  attach_animation(token, metadata.animation_url);
  attach_modules(token, metadata.yours.modules);
}

function _validate_apply_transfer(
  init_transfer_tx: gtx_transaction,
  init_tx_op_index: integer
) {
  val init_transfer_details = _get_init_transfer_details(init_transfer_tx, init_tx_op_index);

  require(
    applied_transfers @? {
      .init_tx_rid == init_transfer_details.tx_rid,
      .init_op_index == init_tx_op_index
    } == null,
    "Transaction <%s> transfer at index <%s> has already been applied on this chain."
      .format(init_transfer_details.tx_rid, init_tx_op_index)
  );

  require(
    canceled_transfers @? { init_transfer_details.tx_rid, init_tx_op_index } == null,
    "Transaction <%s> transfer at index <%s> has already been canceled on this chain."
      .format(init_transfer_details.tx_rid, init_tx_op_index)
  );

  require(
    unapplied_transfers @? { init_transfer_details.tx_rid, init_tx_op_index } == null,
    "Transaction <%s> transfer at index <%s> has already been unapplied on this chain."
      .format(init_transfer_details.tx_rid, init_tx_op_index)
  );

  iccf.require_valid_proof(
    init_transfer_tx,
    require_anchored_proof = true,
    verify_signers = false
  );

  return (init_transfer_details, init_transfer_tx.body.blockchain_rid);
}

function _get_init_transfer_details(tx: gtx_transaction, op_index: integer) {
  val op = tx.body.operations[op_index];

  require(
    op.name == rell.meta(init_transfer).mount_name,
    "Invalid parameters. Expected <%s> at index <%d>, found <%s>"
      .format(rell.meta(init_transfer).mount_name, op_index, op.name)
  );

  val tx_rid = tx.body.hash();
  val args = struct<init_transfer>.from_gtv(op.args.to_gtv());

  val auth_op = tx.body.operations[op_index - 1];
  val sender_account_id = ft4.auth.extract_account_id(auth_op);

  return (
    tx_rid = tx_rid,
    args = args,
    sender_account_id = sender_account_id
  );
}
