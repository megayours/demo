
/**
 * The specification for a token.
 * 
 * @param name The name of the token.
 * @param symbol The symbol of the token.
 * @param decimals The number of decimals of the token.
 * @param icon_url The URL of the icon of the token.
 * @param modules The modules of the token.
 */
struct token_info {
  project: name;
  collection: name;
  name: name;
  modules: list<name>?;
}

/**
 * The specification for a balance mutation.
 * 
 * @param account The account to mint or burn the token from.
 * @param amount The amount of the token to mint or burn.
 */
struct balance_info {
  account: ft4.accounts.account;
  amount: integer;
}

/**
 * The specification for a transfer.
 * 
 * @param from The account to transfer the token from.
 * @param to The account to transfer the token to.
 * @param amount The amount of the token to transfer.
 */
struct transfer_info {
  from: ft4.accounts.account;
  to: ft4.accounts.account;
  amount: integer;
}

/**
 * Define a new token with a specific ID.
 *
 * @param info the information for the token
 * @param token_id the token id
 */
function create_token_with_id(info: token_info, token_id: integer): token {
  val project = ensure_project(info.project);
  val collection = ensure_collection(info.collection, project);
  return _create_token(info, collection, token_id);
}

/**
 * Define a new token on the blockchain.
 *
 * @param info the information for the token
 */
function create_token(info: token_info): token {
  val project = ensure_project(info.project);
  val collection = ensure_collection(info.collection, project);
  return _create_token(info, collection, _get_next_token_id(collection));
}

/**
 * Attach an animation to a token.
 *
 * @param token to attach the animation to
 * @param animation_url to attach
 */
function attach_animation(token, animation_url: text?): token_animation? {
  val token_animation = token_animation @? { token };
  val existing_animation = token_animation?.url;

  if (existing_animation == animation_url) return token_animation;
  if (token_animation != null and existing_animation != animation_url) {
    delete token_animation;
  }

  if (animation_url != null) {
    return create token_animation ( token, animation_url );
  }
  return null;
}

/**
 * Attach a description to a token.
 *
 * @param token to attach the description to
 * @param description to attach
 */
function attach_description(token, description: text?): token_description? {
  val token_description = token_description @? { token };
  val existing_description = token_description?.text;

  if (existing_description == description) return token_description;
  if (token_description != null and existing_description != description) {
    delete token_description;
  }

  if (description != null) {
    return create token_description ( token, description );
  }
  return null;
}

/**
 * Attach an image to a token.
 *
 * @param token to update the image for
 * @param image_url to update
 */
function attach_image(token, image_url: text?): token_image? {
  val token_image = token_image @? { token };
  val existing_image = token_image?.url;

  if (existing_image == image_url) return token_image;
  if (token_image != null and existing_image != image_url) {
    delete token_image;
  }

  if (image_url != null) {
    return create token_image ( token, image_url );
  }

  return null;
}

/**
 * Attach modules to a token.
 *
 * @param token to attach the modules to
 * @param modules to attach
 */
function attach_modules(token, modules: list<name>) {
  for (m in modules) {
    attach_module(token, m);
  }
}

/**
 * Attach a module to a token. Making it eligible to be part of the token's metadata.
 *
 * @param token to attach the module to
 * @param module_name to attach
 */
function attach_module(token, module_name: name) {
  val modules = module_name.split(".");
  val name = modules[modules.size() - 1];

  if (token_module @? { token, name } == null) {
    create token_module ( token, name );
  }
}

/**
 * Mint tokens to a specific account.
 *
 * @param token the token to mint from
 * @param info the information for the mint
 */
function mint(token, info: balance_info) {
  _mint_balance(token, info.account, info.amount);
}

/**
 * Burn tokens from a specific account.
 *
 * @param token the token to burn from
 * @param info the information for the burn
 */
function burn(token, info: balance_info) {
  _burn_balance(token, info.account, info.amount);
}

/**
 * Transfer tokens from one account to another.
 *
 * @param token to transfer
 * @param info the information for the transfer
 */
function transfer(token, info: transfer_info) {
  _burn_balance(token, info.from, info.amount);
  _mint_balance(token, info.to, info.amount);
}

/**
 * Get a token by collection and token id.
 *
 * @param collection the collection name
 * @param token_id the token id
 */
function get_token(project: name, collection: name, token_id: integer): token? {
  return token @? {
    .collection.project.name == project,
    .collection.name == collection,
    .id == token_id
  };
}

/**
 * An active token is one where there exists a balance for the token.
 */
function get_active_token(project: name, collection: name, token_id: integer): token? {
  return token_balance @? {
    .token.collection.project.name == project,
    .token.collection.name == collection,
    .token.id == token_id
  } ( .token );
}

function _create_token(info: token_info, collection, token_id: integer) {
  val token = create token ( info.name, collection, token_id );

  val modules = info.modules;
  if (modules != null) {
    for (m in modules) {
      attach_module(token, m);
    }
  }

  return token;
}

function _get_next_token_id(collection): integer {
  return (token @? { collection } ( @max(.id) ) ?: -1) + 1;
}

function _get_token_balance(token, ft4.accounts.account) {
  return token_balance @? { token, account };
}

function _mint_balance(token, ft4.accounts.account, amount: integer) {
  val receiver_balance = _get_token_balance(token, account);
  if (receiver_balance == null) {
    create token_balance ( token, account, amount );
  } else {
    receiver_balance.amount += amount;
  }
}

function _burn_balance(token, ft4.accounts.account, amount: integer) {
  val token_balance = require(_get_token_balance(token, account), "Insufficient balance");
  val new_amount = token_balance.amount - amount;
  require(new_amount >= 0, "Insufficient balance");

  if (new_amount == 0) {
    delete token_balance;
  } else {
    token_balance.amount = new_amount;
  }
}
