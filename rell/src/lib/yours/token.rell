/**
 * The specification for a token.
 * 
 * @param name The name of the token.
 * @param symbol The symbol of the token.
 * @param decimals The number of decimals of the token.
 * @param icon_url The URL of the icon of the token.
 * @param modules The modules of the token.
 */
struct token_specification {
  project: name;
  collection: name;
  name: name;
  modules: list<name>?;
}

/**
 * The specification for a balance mutation.
 * 
 * @param account The account to mint or burn the token from.
 * @param amount The amount of the token to mint or burn.
 */
struct balance_specification {
  account: ft4.accounts.account;
  amount: integer;
}

/**
 * The specification for a transfer.
 * 
 * @param from The account to transfer the token from.
 * @param to The account to transfer the token to.
 * @param amount The amount of the token to transfer.
 */
struct transfer_specification {
  from: ft4.accounts.account;
  to: ft4.accounts.account;
  amount: integer;
}

/**
 * Define a new token with a specific ID.
 *
 * @param spec the specification for the token
 * @param token_id the token id
 */
function create_token_with_id(spec: token_specification, token_id: integer) {
  val project = ensure_project(spec.project);
  val collection = ensure_collection(spec.collection, project);
  return _create_token(spec, collection, token_id);
}

/**
 * Define a new token on the blockchain.
 *
 * @param spec the specification for the token
 */
function create_token_with_incremental_id(spec: token_specification) {
  val project = ensure_project(spec.project);
  val collection = ensure_collection(spec.collection, project);
  return _create_token(spec, collection, _get_next_token_id(collection));
}

/**
 * Attach an animation to a token.
 *
 * @param token to attach the animation to
 * @param animation_url to attach
 */
function attach_animation(token, animation_url: text?): token_animation? {
  val token_animation = token_animation @? { token };
  val existing_animation = token_animation?.url;

  if (existing_animation == animation_url) return token_animation;
  if (token_animation != null and existing_animation != animation_url) {
    delete token_animation;
  }

  if (animation_url != null) {
    return create token_animation(token, animation_url);
  }
  return null;
}

/**
 * Attach a description to a token.
 *
 * @param token to attach the description to
 * @param description to attach
 */
function attach_description(token, description: text?): token_description? {
  val token_description = token_description @? { token };
  val existing_description = token_description?.text;

  if (existing_description == description) return token_description;
  if (token_description != null and existing_description != description) {
    delete token_description;
  }

  if (description != null) {
    return create token_description(token, description);
  }
  return null;
}

/**
 * Attach an image to a token.
 *
 * @param token to update the image for
 * @param image_url to update
 */
function attach_image(token, image_url: text?) {
  val token_image = token_image @? { token };
  val existing_image = token_image?.url;

  if (existing_image == image_url) return token_image; // No change
  if (token_image != null and existing_image != image_url) {
    delete token_image;
  }

  if (image_url != null) {
    return create token_image(token, image_url);
  }

  return null;
}

/**
 * Attach modules to a token.
 *
 * @param token to attach the modules to
 * @param modules to attach
 */
function attach_modules(token, modules: list<name>) {
  for (m in modules) {
    attach_module(token, m);
  }
}

/**
 * Attach a module to a token. Making it eligible to be part of the token's metadata.
 *
 * @param token to attach the module to
 * @param module_name to attach
 */
function attach_module(token, module_name: name) {
  val modules = module_name.split(".");
  val name = modules[modules.size() - 1];

  if (token_module @? { token, name } == null) {
    create token_module(token, name);
  }
}

/**
 * Mint tokens to a specific account.
 *
 * @param token the token to mint from
 * @param spec the specification for the mint
 */
function mint_tokens(token, spec: balance_specification) {
  _mint_balance(token, spec.account, spec.amount);
}

/**
 * Burn tokens from a specific account.
 *
 * @param token the token to burn from
 * @param spec the specification for the burn
 */
function burn_tokens(token, spec: balance_specification) {
  _burn_balance(token, spec.account, spec.amount);
}

/**
 * Transfer tokens from one account to another.
 *
 * @param token to transfer
 * @param spec the specification for the transfer
 */
function transfer_tokens(token, spec: transfer_specification) {
  _burn_balance(token, spec.from, spec.amount);
  _mint_balance(token, spec.to, spec.amount);
}

/**
 * Get a token by collection and token id.
 *
 * @param collection the collection name
 * @param token_id the token id
 */
function get_token(collection: name, token_id: integer): token? {
  return token @? { .collection.name == collection, .id == token_id };
}

/**
 * An active token is one where there exists a balance for the token.
 */
function get_active_token(collection: name, token_id: integer): token? {
  return token_balance @? { .token.collection.name == collection, .token.id == token_id } ( .token );
}

function _create_token(spec: token_specification, collection, token_id: integer) {
  val token = create token(spec.name, collection, token_id);

  val modules = spec.modules;
  if (modules != null) {
    for (m in modules) {
      attach_module(token, m);
    }
  }

  return token;
}

function _get_next_token_id(collection): integer {
  return (token @? { collection } ( @max(.id) ) ?: -1) + 1;
}

function _get_token_balance(token, ft4.accounts.account) {
  return token_balance @? { token, account };
}

function _mint_balance(token, ft4.accounts.account, amount: integer) {
  val receiver_balance = _get_token_balance(token, account);
  if (receiver_balance == null) {
    create token_balance(token, account, amount);
  } else {
    receiver_balance.amount += amount;
  }
}

function _burn_balance(token, ft4.accounts.account, amount: integer) {
  val token_balance = require(_get_token_balance(token, account), "Insufficient balance");
  val new_amount = token_balance.amount - amount;
  require(new_amount >= 0, "Insufficient balance");

  if (new_amount == 0) {
    delete token_balance;
  } else {
    token_balance.amount = new_amount;
  }
}